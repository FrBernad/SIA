# Authors

- [Francisco Bernad](https://github.com/FrBernad)
- [Nicolás Rampoldi](https://github.com/NicolasRampoldi)
- [Joaquín Legammare](https://github.com/JoacoLega)

# 0-1 KNAPSACK PROBLEM SOLVER

This project aims to solve the [0-1 Knapsack Problem](https://en.wikipedia.org/wiki/Knapsack_problem) using Genetic
Algorithms. The Knapsack Problem is an example of a combinatorial optimization problem, which seeks to maximize the
benefit of objects in a knapsack without exceeding its capacity.

# Requirements

- [Python 3+](https://www.python.org/downloads/)
- [Pipenv](https://pipenv.pypa.io/en/latest/)

# Setup

On the root project folder run the command `pipenv install`. This will install all necessary Python dependencies get the
project up and running.

# Usage

To run the puzzle solver you **MUST** follow the next steps:

1. Generate or modify a yaml config file specifying the algorithm and parameters to be used. You can find a default
   config file (***config.yaml***) explaining all possible parameters value.
2. Run the solver with the following command.

```bash
  pipenv shell 
  python knapsack_solver.py [-h] [-c config_file] [-d data_file] [-o output_file]
```

Where:

- config_file: specifies the path to a valid yaml configuration file. Defaults to **"config.yaml"**
- data_file: specifies the .txt data file to generate the knapsack. Defaults to  **"Mochila100Elementos.txt"**.
- output_file: specifies the path to the output file containing the found solution. Defaults to **"solution.yaml"**

## Configuration File

The configuration file must be a valid yaml file with the following structure:

```
---
#knapsack problem config
config:

  #initial population size (n>5)
  initial_population: initial_population

  #end condition to be used by the solver
  end_condition:

    #defines how many generations should be generated before ending
    generations_count: 'generations_count' #generations_count>=500, defaults to 500

    #defines how many generations should be generated at least before ending via acceptable solution
    acceptable_solution_generation_count: 'acceptable_solution_generation_count' #acceptable_solution_generation_count>=500, defaults to 500

    #used for time type, defines how many seconds should pass before ending
    time: 'time' #time>0, defaults to 5*60

    #defines how many consecutive generations should be generated
    #with a percentage of equal individuals before ending
    structure:
      percentaje: 'percentaje' #(0<p<1), defaults to 0.8
      generations: 'generations' #generations>=10, defaults to 10
      min_generations: 'min_generations' #min_generations>=500, defaults to 500

    #defines how many consecutive generations should be generated
    #with the same best fitness
    fitness:
      generations: 'generations' #generations>=10, defaults to 10
      min_generations: 'min_generations' #min_generations>=500, defaults to 500

  #fitness function to be used by the solver
  #possible options are:
  # - benefit_weight_ratio
  fitness_function: 'fitness_function'

  #couple selection method to be used by the solver
  #possible options are:
  # - rand_couple_selection
  # - fitness_couple_selection
  couple_selection: 'rand_couple_selection'

  #crossover method to be used by the solver
  crossover:
    #possible types are:
    # - simple_crossover
    # - multiple_crossover
    # - uniform_crossover
    type: 'type'

    #used for truncated_selection type, defines how many chromosomes are discarded from the generation
    multiple_crossover:
      n: 'n' # 0<n<initial_population

  #mutation probability used for mutating chromosomes (0<p<1)
  mutation_probability: 'mutation_probability'

  #selection method to be used by the solver
  selection:

    #possible types are:
    # - elitism_selection
    # - roulette_wheel_selection
    # - rank_selection
    # - tournament_selection
    # - boltzmann_selection
    # - truncated_selection
    type: 'type'

    #used for boltzmann_selection type, defines temperature function parameters
    boltzmann_selection:
      Tc: 'Tc' # 0<Tc<T0
      T0: 'T0' # T0>Tc
      k: 'k' # k>0

    #used for truncated_selection type, defines how many chromosomes are discarded from the generation
    truncated_selection:
      truncation_size: 'truncation_size' # 0<truncation_size<=population_size

...
```

## Data File

The configuration file must be a valid txt file with the following structure:

```
max_capacity  max_weight
item_1_weight item_1_benefit
...
...
...
item_n_weight item_n_benefit
```

## Solution File

A solution yaml file will be generated by the solver with the following structure:

```
initial_population: 'initial_population'
end_condition: 'end_condition'
fitness_function: 'fitness_function'
couple_selection: 'couple_selection'
crossover: 'crossover'
mutation_probability: 'mutation_probability'
selection: 'selection' 
solution: 
  genes: 'genes'
  fitness: 'fitness'
  weight: 'weight'
  benefit: 'benefit'
```